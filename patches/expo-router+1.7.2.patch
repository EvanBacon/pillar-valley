diff --git a/node_modules/expo-router/entry.js b/node_modules/expo-router/entry.js
index 83600a4..cf0721c 100644
--- a/node_modules/expo-router/entry.js
+++ b/node_modules/expo-router/entry.js
@@ -1,6 +1,6 @@
+import "@expo/metro-runtime";
 import { ExpoRoot } from "expo-router";
 import Head from "expo-router/head";
-import "@expo/metro-runtime";
 import { renderRootComponent } from "expo-router/src/renderRootComponent";
 
 const ctx = require.context(
diff --git a/node_modules/expo-router/src/ExpoRoot.tsx b/node_modules/expo-router/src/ExpoRoot.tsx
index 3cef759..cdb447d 100644
--- a/node_modules/expo-router/src/ExpoRoot.tsx
+++ b/node_modules/expo-router/src/ExpoRoot.tsx
@@ -3,6 +3,7 @@ import { StatusBar } from "expo-status-bar";
 import React from "react";
 import { Platform } from "react-native";
 import { SafeAreaProvider } from "react-native-safe-area-context";
+import * as SplashModule from "expo-splash-screen";
 
 import { getRouteInfoFromState } from "./LocationProvider";
 import UpstreamNavigationContainer from "./fork/NavigationContainer";
@@ -73,9 +74,6 @@ function ContextNavigator({
   location: initialLocation = initialUrl,
 }: ExpoRootProps) {
   const navigationRef = useNavigationContainerRef();
-  const [shouldShowSplash, setShowSplash] = React.useState(
-    Platform.OS !== "web"
-  );
 
   const expoContext = React.useMemo<
     ExpoRouterContextType | OnboardingExpoRouterContextType
@@ -142,11 +140,21 @@ function ContextNavigator({
         state,
         routeInfo: getRouteInfo(state),
       });
+      // subscription?.();
     });
 
     return () => subscription?.();
   }, [navigationRef, getRouteInfo]);
 
+  const Component = routeNode ? getQualifiedRouteComponent(routeNode) : null;
+
+  const comp = React.useMemo(() => {
+    if (!Component) {
+      return null;
+    }
+    return <Component />;
+  }, [Component]);
+
   if (!routeNode) {
     if (process.env.NODE_ENV === "development") {
       const Tutorial = require("./onboard/Tutorial").Tutorial;
@@ -157,20 +165,19 @@ function ContextNavigator({
     }
   }
 
-  const Component = getQualifiedRouteComponent(routeNode);
-
   return (
     <>
-      {shouldShowSplash && <SplashScreen />}
       <ExpoRouterContext.Provider value={expoContext}>
         <UpstreamNavigationContainer
           ref={navigationRef}
           initialState={initialState}
           linking={linking}
-          onReady={() => requestAnimationFrame(() => setShowSplash(false))}
+          onReady={() => {
+            SplashModule._router_unlockAsync()
+          }}
         >
           <RootStateContext.Provider value={rootState}>
-            {!shouldShowSplash && <Component />}
+            {comp}
           </RootStateContext.Provider>
         </UpstreamNavigationContainer>
       </ExpoRouterContext.Provider>
diff --git a/node_modules/expo-router/src/static/renderStaticContent.tsx b/node_modules/expo-router/src/static/renderStaticContent.tsx
index 2c82675..c7cfd42 100644
--- a/node_modules/expo-router/src/static/renderStaticContent.tsx
+++ b/node_modules/expo-router/src/static/renderStaticContent.tsx
@@ -1,3 +1,4 @@
+
 /**
  * Copyright Â© 2023 650 Industries.
  *
diff --git a/node_modules/expo-router/src/views/Splash.tsx b/node_modules/expo-router/src/views/Splash.tsx
index ece327e..f98473b 100644
--- a/node_modules/expo-router/src/views/Splash.tsx
+++ b/node_modules/expo-router/src/views/Splash.tsx
@@ -3,6 +3,32 @@ import { nanoid } from "nanoid/non-secure";
 import * as React from "react";
 import { Platform } from "react-native";
 
+
+if (!SplashModule.hideAsync.__router_lock) {
+  // Lock the method so it can only be called once
+  SplashModule.hideAsync.__router_lock = true;
+  const original = SplashModule.hideAsync.bind(SplashModule);
+  SplashModule._router_lockAsync = async () => {
+    SplashModule._unlocked = false;
+  };
+  SplashModule._router_unlockAsync = async () => {
+    SplashModule._unlocked = true;
+    if (SplashModule._unlock) {
+      SplashModule._unlock();
+    }
+  };
+  // Override the method so it can only be called once
+  SplashModule.hideAsync = async () => {
+    if (SplashModule._unlocked) {
+      return original();
+    } else {
+      return new Promise((resolve) => {
+        SplashModule._unlock = resolve;
+      });
+    }
+  };
+}
+
 const globalStack: string[] = [];
 
 /**
@@ -56,6 +82,7 @@ SplashScreen.preventAutoHideAsync = () => {
     return;
   }
   _preventAutoHideAsyncInvoked = true;
+  SplashModule._router_lockAsync();
   // Append error handling to ensure any uncaught exceptions result in the splash screen being hidden.
   if (Platform.OS !== "web" && ErrorUtils?.getGlobalHandler) {
     const originalHandler = ErrorUtils.getGlobalHandler();
@@ -71,6 +98,7 @@ SplashScreen._pushEntry = (): any => {
   const entry = nanoid();
   globalStack.push(entry);
   SplashScreen.preventAutoHideAsync();
+  console.log('push:', globalStack.length)
   return entry;
 };
 
@@ -79,6 +107,7 @@ SplashScreen._popEntry = (entry: string) => {
   if (index !== -1) {
     globalStack.splice(index, 1);
   }
+  console.log('pop:', globalStack.length)
   if (globalStack.length === 0) {
     SplashScreen.hideAsync();
   }
